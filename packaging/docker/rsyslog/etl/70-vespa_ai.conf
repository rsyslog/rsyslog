module(load="omhttp")

# template that outputs the message field in a JSON document
# -> go wild and make your own documents
# -> make sure you have the "fields" object on top
# -> see https://docs.vespa.ai/en/document-v1-api-guide.html
template(name="vespa-raw" type="list" option.json="on") {
    constant(value="{ \"fields\": { \"message\": \"")
    property(name="msg")
    constant(value="\" }}")
}

# template that outputs Vespa path + random doc ID
# -> fill in NAMESPACE and DOCTYPE. These can also be dynamic
#template(name="vespaDocUrl" type="string"
#  string="/document/v1/NAMESPACE/DOCTYPE/docid/%uuid%"
#)
template(name="vespaDocUrl" type="list") {
  constant(value="/document/v1/")
  constant(value=`echo ${VESPA_NAMESPACE}/`)
  constant(value=`echo ${VESPA_DOCTYPE}/`)
  constant(value="docid/")
  property(name="uuid")
}

# writing to Vespa. You can have retries, define what to do on retries, etc.
# -> more info at https://www.rsyslog.com/doc/configuration/modules/omhttp.html
action(type="omhttp" config.enabled=`echo $ENABLE_VESPA`
       # Vespa host and port
       server=`echo ${VESPA_SERVER}`
       serverport=`echo ${VESPA_PORT}`
       # TODO: add --> for secure endpoints (e.g., Vespa Cloud), you can provide certs and all
       useHttps="off"
       
       # no batching, but maybe HTTP/2 in the future
       # -> see https://blog.vespa.ai/http2
       batch="off"
       
       # point to the template that outputs random doc ID
       dynrestpath="on"
       restpath="vespaDocUrl"
       
       # template making JSON documents to send to Vespa
       # TODO: we possibly need different template for native JSON data (plus other plumbing)
       template="vespa-raw"
)
